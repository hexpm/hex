defmodule Mix.Tasks.Hex.Docs do
  use Mix.Task
  alias Mix.Hex.Utils

  @shortdoc "Publishes docs for package"

  @moduledoc """
  Publishes documentation for the current project and version.

  The documentation will be accessible at `https://hexdocs.pm/my_package/1.0.0`,
  `https://hexdocs.pm/my_package` will always redirect to the latest published
  version.

  Documentation will be generated by running the `mix docs` task. `ex_doc`
  provides this task by default, but any library can be used. Or an alias can be
  used to extend the documentation generation. The expected result of the task
  is the generated documentation located in the `docs/` directory with an
  `index.html` file.

  ## Command line options

    * `--revert VERSION` - Revert given version
  """

  @switches [revert: :string, progress: :boolean]

  def run(args) do
    Hex.start

    {opts, _, _} = OptionParser.parse(args, switches: @switches)
    auth = Utils.auth_info()

    Mix.Project.get!
    config  = Mix.Project.config
    name    = config[:package][:name] || config[:app]
    version = config[:version]

    if revert = opts[:revert] do
      revert(name, revert, auth)
    else
      try do
        docs_args = ["--canonical", Hex.Utils.hexdocs_url(name)|args]
        Mix.Task.run("docs", docs_args)
      rescue ex in [Mix.NoTaskError] ->
        stacktrace = System.stacktrace
        Mix.shell.error ~s(The "docs" task is unavailable, add {:ex_doc, ">= x.y.z", only: [:dev]}) <>
                        ~s( to your dependencies or if ex_doc was already added make sure you run) <>
                        ~s( the task in the same environment it is configured to)
        reraise ex, stacktrace
      end

      directory = docs_dir()

      unless File.exists?("#{directory}/index.html") do
        Mix.raise "File not found: #{directory}/index.html"
      end

      progress? = Keyword.get(opts, :progress, true)
      tarball = build_tarball(name, version, directory)
      send_tarball(name, version, tarball, auth, progress?)
    end
  end

  defp build_tarball(name, version, directory) do
    tarball = "#{name}-#{version}-docs.tar.gz"
    files = files(directory)
    :ok = :erl_tar.create(tarball, files, [:compressed])
    data = File.read!(tarball)

    File.rm!(tarball)
    data
  end

  defp send_tarball(name, version, tarball, auth, progress?) do
    progress =
      if progress? do
        Utils.progress(byte_size(tarball))
      else
        Utils.progress(nil)
      end

    case Hex.API.ReleaseDocs.new(name, version, tarball, auth, progress) do
      {code, _} when code in 200..299 ->
        Hex.Shell.info ""
        Hex.Shell.info "Published docs for #{name} #{version}"
        # TODO: Only print this URL if we use the default API URL
        Hex.Shell.info "Hosted at #{Hex.Utils.hexdocs_url(name, version)}"
      {code, body} ->
        Hex.Shell.info ""
        Hex.Shell.error "Pushing docs for #{name} v#{version} failed"
        Hex.Utils.print_error_result(code, body)
    end
  end

  defp revert(name, version, auth) do
    version = Utils.clean_version(version)

    case Hex.API.ReleaseDocs.delete(name, version, auth) do
      {code, _} when code in 200..299 ->
        Hex.Shell.info "Reverted docs for #{name} #{version}"
      {code, body} ->
        Hex.Shell.error "Reverting docs for #{name} #{version} failed"
        Hex.Utils.print_error_result(code, body)
    end
  end

  defp files(directory) do
    "#{directory}/**"
    |> Path.wildcard
    |> Enum.filter(&File.regular?/1)
    |> Enum.map(&{relative_path(&1, directory), File.read!(&1)})
  end

  defp relative_path(file, dir) do
    Path.relative_to(file, dir)
    |> String.to_char_list
  end

  defp docs_dir do
    cond do
      File.exists?("doc") ->
        "doc"
      File.exists?("docs") ->
        "docs"
      true ->
        Mix.raise("Documentation could not be found. Please ensure documentation is in the doc/ or docs/ directory")
    end
  end
end
